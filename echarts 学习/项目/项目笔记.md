# KOA2 学习笔记

## KOA2的介绍

- 基于 Node.js 平台的Web服务器框架

- 由 Express 原班人马打造

  Express Koa , Koa2 都是 Web 服务器的框架,他们之间的差别和关系可以通过下面这个表格表示出来：

  | 框架名  | 作用     | 异步处理        |
  | ------- | -------- | --------------- |
  | Express | web 框架 | 回调函数        |
  | Koa     | web 框架 | Generator+yield |
  | Koa2    | web 框架 | async/await     |

- 环境依赖 Node v7.6.0 及以上

  由于 Koa2 它是支持 async 和 await，所以它对 Node 的版本是有要求的，它要求 Node 的版本至 少是在7.6级以上, 因为语法糖 async和await 是在 Node7.6 版本之后出现才支持。、

- 洋葱中间件

  如下图所示, 对于服务器而言，它其实就是来处理一个又一个的请求。Web 服务器接收由浏览器发过来的一个又一个请求之后，它形成一个又一个的响应返回给浏览器。

  而请求到达我们的服务器是需要经过程序处理的，程序处理完之后才会形成响应，返回给浏览器，我们服务器处理请求的这一块程序，在 Koa2 的世界当中就把它称之为中间件。

  ![image-20210930160316573](https://gitee.com/zyxbj/image-warehouse/raw/master/pics/202109301603620.png)

  这种中间件可能还不仅仅只有一个，可能会存在多个，比如上图所示, 它就存在三层中间件，这三层中间件在处理请求的过程以及它调用的顺序为:

  - 当一个请求到达服务器，最先处理这个请求的是第一层中间件
  - 第一层的中间件在处理这个请求之后，它会把这个请求给第二层的中间件
  - 第二层的中间件在处理这个请求之后，它会把这个请求给第三层的中间件
  - 第三层中间件内部并没有中间件了, 所以第三层中间件在处理完所有的代码之后，这个请求又会到了第二层的中间件，所以第二层中间件对这个请求处理了`两次`。
  - 第二层的中间件在处理完这个请求之后，又到了第一层的中间件, 所以第一层的中间件也对这个请求处理了`2次`。

  这个调用顺序就是洋葱模型, 中间件对请求的处理有一种先进后出的感觉，请求最先到达第一层中间件，而最后也是第一层中间件对请求再次处理了一下。

## koa2快速上手

- 检查node环境是否大于7.6

  `node -v` 

- 安装koa(！注意是koa，不是koa2)

  ```js
  yarn add koa
  ```

- 创建并编写app.js文件

  1. 创建koa对象
  2. 编写相应函数
  3. 监听端口

  ```js
  // 1.创建koa的对象
  const koa = require('koa');
  const app = new koa();
  // 2.编写响应函数（中间件）
  // ctx 上下文 ctx.request,ctx.response
  // next 下一个中间件是否能够被执行，取决于这个next函数有没有被调用
  app.use((ctx,next)=>{
    console.log(ctx.request.url);
    ctx.response.body = 'hello world';
  })
  
  // 3.监听端口
  app.listen(3000);
  ```



## koa2 中间件的特点

- Koa2 的实例对象通过 use 方法加入一个中间件

- 一个中间件就是一个函数,这个函数具备两个参数,分别是 ctx 和 next

- 中间件的执行符合洋葱模型

  ```js
  // 1.创建koa的对象
  const koa = require('koa');
  const app = new koa();
  // 2.编写响应函数（中间件）
  // ctx 上下文 ctx.request,ctx.response
  // next 下一个中间件是否能够被执行，取决于这个next函数有没有被调用
  app.use((ctx,next)=>{
    console.log('第一层中间件');
    ctx.response.body = 'hello world';
    next();
    console.log('第一层中间件...1');
  })
  // 第二层中间件
  app.use((ctx,next)=>{
    console.log('第二层中间件');
    next();
    console.log('第二层中间件...2');
  })
  // 第三层中间件
  app.use((ctx,next)=>{
    console.log('第三层中间件');
  
  })
  
  
  // 3.监听端口
  app.listen(3000);
  
  //第一层中间件
  //第二层中间件
  //第三层中间件
  //第二层中间件...2
  //第一层中间件...1
  ```

- 内层中间件能否执行取决于外层中间件的 next 函数是否调用

- 调用 next 函数得到的是 Promise 对象, 如果想得到 Promise 所包装的数据, 可以结合 await 和 async

  ```js
  // 1.创建koa的对象
  const koa = require('koa');
  const app = new koa();
  // 2.编写响应函数（中间件）
  
  // 第一层中间件
  app.use((ctx,next)=>{
    console.log('第一层中间件');
    let data= next();
    console.log(data); //Promise { 'I want to sleep' }
    console.log('第一层中间件...1');
  })
  // 第二层中间件
  app.use((ctx,next)=>{
    console.log('第二层中间件');
    return 'I want to sleep'
  })
  
  
  // 3.监听端口
  app.listen(3000);
  ```

  

  ```js
  app.use(async(ctx, next)=>{
      // 刚进入中间件想做的事情
      await next();
      //内层所有中间件结束后想做的事情
  })
  ```

  

## 小项目实战

### 项目的目标

1. 计算服务器处理请求的总耗时

2. 在响应头上加上响应内容的mime类型

   加入[mime](https://baijiahao.baidu.com/s?id=1664315464064488248&wfr=spider&for=pc)类型, 可以让浏览器更好的来处理由服务器返回的数据。

   如果响应给前端浏览器是 json 格式的数据，这时候就需要在咱们的响应头当中增加 `Content-Type:application/json`。application/json 就是 json 数据类型的 mime 类型。

3. 根据url读取指定目标下文件内容

### 项目实现步骤

#### 1.项目准备

安装包：

```bash
yarn add koa
```

创建文件和目录结构：

```html
app.js
data/
middleware/
	koa_response_data.js
	koa_response_duration.js
	koa_respone_header.js
utils/
	file_utils.js
```

#### 2. 总耗时中间件

- 总耗时中间件应第一层的中间件

- 一进入第一层中间件记录开始时间，其他所有中间件执行完成后记录结束时间，两者相减

- 设置响应头 `X-Response-Times:5ms`

  ```js
  module.exports = async (ctx,next)=>{
      // 记录开始时间
      const start = Date.now();
      // 让内层中间件执行
      await next();
  
      // 记录结束时间
      const end = Date.now();
      // 设置响应头 X-Response-Time
      // ctx.set 设置响应头
      ctx.set('X-Response-Time', `${end - start}ms`);
  }
  ```

#### 3.响应头中间件

- 获取 mime 类型

  application/json

- 设置响应头

  `Content-Type: application/json; charset = UTF-8`

  ```js
  // 设置响应头的中间件
  module.exports = async (ctx, next) => {
      const contentType = 'application/json; charset=utf-8';
      ctx.set('Content-Type',contentType);
      ctx.response.body = '{"sucess":true}'
      await next();
  }
  ```

#### 4.业务逻辑中间件

- 读取文件内容 如`http://127.0.0.1/api/seller`

  - 获取请求的路径，拼接文件路径
  - 读取该路径对应的文件的内容

- 设置响应体

  `ctx.response.body`
  
  ```js
  // koa_response_data.js
  const path = require('path');
  const fileUtils = require('../utils/file_utils.js');
  
  // 处理业务逻辑的中间件
  module.exports = async (ctx, next) => {
      // 获取请求地址
      const url = ctx.request.url; //将/api/seller 变化为../data/seller.json
      if (url.includes('api')) {
          const filePath = path.join(__dirname, '../data', url.replace('api', '') + '.json');
          const data = await fileUtils.getData(filePath);
          ctx.response.body = data;
      }
      await next();
  }
  ```
  
  ```js
  //file_utils.js
  const path = require('path');
  const fileUtils = require('../utils/file_utils.js');
  
  // 处理业务逻辑的中间件
  module.exports = async (ctx, next) => {
      // 获取请求地址
      const url = ctx.request.url; //将/api/seller 变化为../data/seller.json
      if (url.includes('api')) {
          const filePath = path.join(__dirname, '../data', url.replace('api', '') + '.json');
          const data = await fileUtils.getData(filePath);
          ctx.response.body = data;
      }
      await next();
  }
  ```

- 接口总览
  1. 商家销量 /api/seller
  2. 预算开销 /api/budget
  3. 库存信息 /api/stock
  4. 销量趋势 /api/trend
  5. 销量排行 /api/rank
  6. 商家分步 /api/map
  7. 热销商品 /api/hotproduct

#### 5.允许跨域

- 实际中是通过ajax访问服务器

- 同源策略

  同协议\同域名\同端口

  当前页面地址和Ajax获取数据的地址

- 设置响应头

  ```js
  // 设置响应头的中间件
  module.exports = async (ctx, next) => {
      const contentType = 'application/json; charset=utf-8';
      ctx.set('Content-Type',contentType);
      ctx.set('Access-Control-Allow-Origin',"*");
      ctx.set('Access-Control-Allow-Methods',"OPTIONS, GET, PUT, POST, DELETE");
      await next();
  }
  ```

全部代码：[点击此处](https://github.com/liujiaqi222/examples/tree/master/1.koa-server)


# 前端页面

## 图表结构

```js
<script>
export default {
  data(){
    return {
      chartInstance:null,
      allData:null, //从服务器中获取的所有数据
    }
  },
  methods:{
    // 初始化echarts实例对象的方法
    initChart(){
      this.chartInstance=this.$echarts.init(this.$refs.trend_ref);
      const initOption = {};
      this.chartInstance.setOption(initOption);
    },
    async getData(){

      // 获取数据

      this.updateChart(); //处理数据
    },
    updateChart(){
      // 处理数据
      const dataOption = {},
      this.chartInstance.setOption(dataOption);
    },
    // 处理屏幕分辨率
    screenAdapter(){
      const adapterOption = {};
      this.chartInstance.setOption(adapterOption);
      this.chartInstance.resize();
    }
  },
  mounted(){
    this.initChart();
    this.screenAdapter();
    window.addEventListener('resize',this.screenAdapter);
    this.$once('hook:beforeDestory',()=>{
      window.removeEventListener('resize',this.screenAdapter);
    })
  },
  created(){
    this.getData();

  }
}
</script>

```